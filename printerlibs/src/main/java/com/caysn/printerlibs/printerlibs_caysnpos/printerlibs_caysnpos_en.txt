
package com.caysn.printerlibs.printerlibs_caysnpos;

import android.graphics.Bitmap;

import java.io.ByteArrayOutputStream;

import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.Platform;
import com.sun.jna.Pointer;
import com.sun.jna.WString;
import com.sun.jna.ptr.*;

public interface printerlibs_caysnpos extends Library {

    // static interface method need jdk1.8. here we use inner class to avoid this porblem.
    public class GetLibraryPath_Helper {
        // can replaced by absolute path
        public static String GetLibraryPath() {
            // force call JNI_OnLoad
            if (Platform.isAndroid())
                System.loadLibrary("PrinterLibs");
            return "PrinterLibs";
        }
    }
    public static final printerlibs_caysnpos INSTANCE = (printerlibs_caysnpos) Native.loadLibrary(GetLibraryPath_Helper.GetLibraryPath(), printerlibs_caysnpos.class);


    public static final int ComDataBits_4 = 4;
    public static final int ComDataBits_5 = 5;
    public static final int ComDataBits_6 = 6;
    public static final int ComDataBits_7 = 7;
    public static final int ComDataBits_8 = 8;


    public static final int ComParity_NoParity = 0;
    public static final int ComParity_OddParity = 1;
    public static final int ComParity_EvenParity = 2;
    public static final int ComParity_MarkParity = 3;
    public static final int ComParity_SpaceParity = 4;


    public static final int ComStopBits_One = 0;
    public static final int ComStopBits_OnePointFive = 1;
    public static final int ComStopBits_Two = 2;


    public static final int ComFlowControl_None = 0;
    public static final int ComFlowControl_XonXoff = 1;
    public static final int ComFlowControl_RtsCts = 2;
    public static final int ComFlowControl_DtrDsr = 3;


    public static final int PL_QUERYBUFFER_EMTPY = 0;
    public static final int PL_QUERYBUFFER_FAILED_PORT_CLOSED = -1;
    public static final int PL_QUERYBUFFER_FAILED_PORT_WRITEFAILED = -2;
    public static final int PL_QUERYBUFFER_FAILED_PORT_READFAILED = -3;
    public static final int PL_QUERYBUFFER_NOT_EMPTY = -4;


    public static final int PL_PRINTRESULT_SUCCESS = 0;
    public static final int PL_PRINTRESULT_PORT_CLOSED = -1;
    public static final int PL_PRINTRESULT_PORT_WRITEFAILED = -2;
    public static final int PL_PRINTRESULT_PORT_READFAILED = -3;
    public static final int PL_PRINTRESULT_PRINTER_OFFLINE = -102;
    public static final int PL_PRINTRESULT_PRINTER_NOPAPER = -103;
    public static final int PL_PRINTRESULT_OTHER_RERROR = -101;


    public class PL_PRINTERSTATUS_Helper {
        public static boolean PL_PRINTERSTATUS_QUERYFAILED(long status) { return (status == -1); };
        public static boolean PL_PRINTERSTATUS_DRAWER_OPENED(long status) { return (((status >> 0) & 0x04) == 0x00); };
        public static boolean PL_PRINTERSTATUS_OFFLINE(long status) { return (((status >> 0) & 0x08) == 0x08); };
        public static boolean PL_PRINTERSTATUS_COVERUP(long status) { return (((status >> 8) & 0x04) == 0x04); };
        public static boolean PL_PRINTERSTATUS_FEED_PRESSED(long status) { return (((status >> 8) & 0x08) == 0x08); };
        public static boolean PL_PRINTERSTATUS_NOPAPER(long status) { return (((status >> 8) & 0x20) == 0x20); };
        public static boolean PL_PRINTERSTATUS_ERROR_OCCURED(long status) { return (((status >> 8) & 0x40) == 0x40); };
        public static boolean PL_PRINTERSTATUS_CUTTER_ERROR(long status) { return (((status >> 16) & 0x08) == 0x08); };
        public static boolean PL_PRINTERSTATUS_UNRECOVERABLE_ERROR(long status) { return (((status >> 16) & 0x20) == 0x20); };
        public static boolean PL_PRINTERSTATUS_DEGREE_OR_VOLTAGE_OVERRANGE(long status) { return (((status >> 16) & 0x40) == 0x40); };
        public static boolean PL_PRINTERSTATUS_PAPER_NEAREND(long status) { return (((status >> 24) & 0x0C) == 0x0C); };
        public static boolean PL_PRINTERSTATUS_PAPER_TAKEOUT(long status) { return (((status >> 24) & 0x04) == 0x04); };
    }


    public static final int PrintDensity_Light = 0;
    public static final int PrintDensity_Normal = 1;
    public static final int PrintDensity_Dark = 2;


    public static final int PosAlignment_Left = 0;
    public static final int PosAlignment_HCenter = 1;
    public static final int PosAlignment_Right = 2;


    public static final int MultiByteModeEncoding_GBK = 0;
    public static final int MultiByteModeEncoding_UTF8 = 1;
    public static final int MultiByteModeEncoding_BIG5 = 3;
    public static final int MultiByteModeEncoding_ShiftJIS = 4;
    public static final int MultiByteModeEncoding_EUCKR = 5;


    public static final int AsciiTextFontType_A = 0;
    public static final int AsciiTextFontType_B = 1;
    public static final int AsciiTextFontType_C = 2;
    public static final int AsciiTextFontType_D = 3;
    public static final int AsciiTextFontType_E = 4;


    public static final int TextUnderline_None = 0;
    public static final int TextUnderline_One = 1;
    public static final int TextUnderline_Two = 2;


    public static final int CharacterSet_USA = 0;
    public static final int CharacterSet_FRANCE = 1;
    public static final int CharacterSet_GERMANY = 2;
    public static final int CharacterSet_UK = 3;
    public static final int CharacterSet_DENMARK_I = 4;
    public static final int CharacterSet_SWEDEN = 5;
    public static final int CharacterSet_ITALY = 6;
    public static final int CharacterSet_SPAIN_I = 7;
    public static final int CharacterSet_JAPAN = 8;
    public static final int CharacterSet_NORWAY = 9;
    public static final int CharacterSet_DENMARK_II = 10;
    public static final int CharacterSet_SPAIN_II = 11;
    public static final int CharacterSet_LATIN = 12;
    public static final int CharacterSet_KOREA = 13;
    public static final int CharacterSet_SLOVENIA = 14;
    public static final int CharacterSet_CHINA = 15;


    public static final int CharacterCodepage_CP437 = 0;
    public static final int CharacterCodepage_KATAKANA = 1;
    public static final int CharacterCodepage_CP850 = 2;
    public static final int CharacterCodepage_CP860 = 3;
    public static final int CharacterCodepage_CP863 = 4;
    public static final int CharacterCodepage_CP865 = 5;
    public static final int CharacterCodepage_WCP1251 = 6;
    public static final int CharacterCodepage_CP866 = 7;
    public static final int CharacterCodepage_MIK = 8;
    public static final int CharacterCodepage_CP755 = 9;
    public static final int CharacterCodepage_IRAN = 10;
    public static final int CharacterCodepage_CP862 = 15;
    public static final int CharacterCodepage_WCP1252 = 16;
    public static final int CharacterCodepage_WCP1253 = 17;
    public static final int CharacterCodepage_CP852 = 18;
    public static final int CharacterCodepage_CP858 = 19;
    public static final int CharacterCodepage_IRAN_II = 20;
    public static final int CharacterCodepage_LATVIAN = 21;
    public static final int CharacterCodepage_CP864 = 22;
    public static final int CharacterCodepage_ISO_8859_1 = 23;
    public static final int CharacterCodepage_CP737 = 24;
    public static final int CharacterCodepage_WCP1257 = 25;
    public static final int CharacterCodepage_THAI = 26;
    public static final int CharacterCodepage_CP720 = 27;
    public static final int CharacterCodepage_CP855 = 28;
    public static final int CharacterCodepage_CP857 = 29;
    public static final int CharacterCodepage_WCP1250 = 30;
    public static final int CharacterCodepage_CP775 = 31;
    public static final int CharacterCodepage_WCP1254 = 32;
    public static final int CharacterCodepage_WCP1255 = 33;
    public static final int CharacterCodepage_WCP1256 = 34;
    public static final int CharacterCodepage_WCP1258 = 35;
    public static final int CharacterCodepage_ISO_8859_2 = 36;
    public static final int CharacterCodepage_ISO_8859_3 = 37;
    public static final int CharacterCodepage_ISO_8859_4 = 38;
    public static final int CharacterCodepage_ISO_8859_5 = 39;
    public static final int CharacterCodepage_ISO_8859_6 = 40;
    public static final int CharacterCodepage_ISO_8859_7 = 41;
    public static final int CharacterCodepage_ISO_8859_8 = 42;
    public static final int CharacterCodepage_ISO_8859_9 = 43;
    public static final int CharacterCodepage_ISO_8859_15 = 44;
    public static final int CharacterCodepage_THAI_2 = 45;
    public static final int CharacterCodepage_CP856 = 46;
    public static final int CharacterCodepage_CP874 = 47;
    public static final int CharacterCodepage_TCVN3 = 48;


    public static final int BarcodeReadableTextFontType_Standard = 0;
    public static final int BarcodeReadableTextFontType_Small = 1;


    public static final int BarcodeReadableTextPosition_None = 0;
    public static final int BarcodeReadableTextPosition_AboveBarcode = 1;
    public static final int BarcodeReadableTextPosition_BelowBarcode = 2;
    public static final int BarcodeReadableTextPosition_AboveAndBelowBarcode = 3;


    public static final int PosBarcodeType_UPCA = 0x41;
    public static final int PosBarcodeType_UPCE = 0x42;
    public static final int PosBarcodeType_EAN13 = 0x43;
    public static final int PosBarcodeType_EAN8 = 0x44;
    public static final int PosBarcodeType_CODE39 = 0x45;
    public static final int PosBarcodeType_ITF = 0x46;
    public static final int PosBarcodeType_CODEBAR = 0x47;
    public static final int PosBarcodeType_CODE93 = 0x48;
    public static final int PosBarcodeType_CODE128 = 0x49;


    public static final int QRCodeECC_L = 1;
    public static final int QRCodeECC_M = 2;
    public static final int QRCodeECC_Q = 3;
    public static final int QRCodeECC_H = 4;


    public static final int ImagePixelsFormat_MONO = 1;
    public static final int ImagePixelsFormat_MONOLSB = 2;
    public static final int ImagePixelsFormat_GRAY8 = 3;
    public static final int ImagePixelsFormat_BYTEORDERED_RGB24 = 4;
    public static final int ImagePixelsFormat_BYTEORDERED_BGR24 = 5;
    public static final int ImagePixelsFormat_BYTEORDERED_ARGB32 = 6;
    public static final int ImagePixelsFormat_BYTEORDERED_RGBA32 = 7;
    public static final int ImagePixelsFormat_BYTEORDERED_ABGR32 = 8;
    public static final int ImagePixelsFormat_BYTEORDERED_BGRA32 = 9;


    public static final int ImageBinarizationMethod_Dithering = 0;
    public static final int ImageBinarizationMethod_Thresholding = 1;


    public static final int ImageCompressionMethod_None = 0;
    public static final int ImageCompressionMethod_Level1 = 1;
    public static final int ImageCompressionMethod_Level2 = 2;

//      get library version string
//
//  return
//      return library version string
    public String CaysnPos_LibraryVersion();

//      Enumerate serial port
//
//  pBuf
//      The buffer to save enumerated port list
//
//  cbBuf
//      The buffer size
//
//  pcbNeeded
//      The buffer bytes needed
//
//  return
//      Enumerated port count
    public int CaysnPos_EnumComA(byte[] pBuf, int cbBuf, IntByReference pcbNeeded);
    //public int CaysnPos_EnumComW(byte[] pBuf, int cbBuf, IntByReference pcbNeeded);
    public class CaysnPos_EnumCom_Helper {
        public static String[] CaysnPos_EnumComA() {
            IntByReference pcbNeeded = new IntByReference();
            INSTANCE.CaysnPos_EnumComA(null, 0, pcbNeeded);
            if (pcbNeeded.getValue() > 0) {
                byte[] pBuf = new byte[pcbNeeded.getValue()];
                if (pBuf != null) {
                    INSTANCE.CaysnPos_EnumComA(pBuf, pBuf.length, null);
                    String s = new String(pBuf);
                    String[] ss = s.split("\0");
                    return ss;
                }
            }
            return null;
        }
    }

//      Enumerate usb port
//
//  pBuf
//      The buffer to save enumerated port list
//
//  cbBuf
//      The buffer size
//
//  pcbNeeded
//      The buffer bytes needed
//
//  return
//      Enumerated port count
    public int CaysnPos_EnumUsbVidPidA(byte[] pBuf, int cbBuf, IntByReference pcbNeeded);
    //public int CaysnPos_EnumUsbVidPidW(byte[] pBuf, int cbBuf, IntByReference pcbNeeded);
    public class CaysnPos_EnumUsbVidPid_Helper {
        public static String[] CaysnPos_EnumUsbVidPidA() {
            IntByReference pcbNeeded = new IntByReference();
            INSTANCE.CaysnPos_EnumUsbVidPidA(null, 0, pcbNeeded);
            if (pcbNeeded.getValue() > 0) {
                byte[] pBuf = new byte[pcbNeeded.getValue()];
                if (pBuf != null) {
                    INSTANCE.CaysnPos_EnumUsbVidPidA(pBuf, pBuf.length, null);
                    String s = new String(pBuf);
                    String[] ss = s.split("\0");
                    return ss;
                }
            }
            return null;
        }
    }

//      Enumerate net printer
//
//  timeout
//      enumrate timeout ms
// 
//  cancel
//      cancel bit, if value is non-zero, enum process will exit.
//  
//  on_discovered
//      enumrated scanCallback function
//
//  private_data
//      the parameter passed to scanCallback function
//
//  return
//      none
    interface on_netprinter_discovered_a_callback extends Callback {
        void on_netprinter_discovered_a(String local_ip, String discovered_mac, String discovered_ip, String discovered_name, Pointer private_data);
    }
    public void CaysnPos_EnumNetPrinterA(int timeout, IntByReference cancel, on_netprinter_discovered_a_callback scanCallback, Pointer data);

//      Enumerate bt 2.0 printer
//
//  on_discovered
//      enumrated scanCallback function
//
//  private_data
//      the parameter passed to scanCallback function
//
//  return
//      none
    interface on_btdevice_discovered_a_callback extends Callback {
        void on_btdevice_discovered_a(String device_name, String device_address, Pointer private_data);
    }
    public void CaysnPos_EnumBtDeviceA(int timeout, IntByReference cancel, on_btdevice_discovered_a_callback scanCallback, Pointer data);

//      Enumerate bt 4.0 printer
//
//  on_discovered
//      enumrated scanCallback function
//
//  private_data
//      the parameter passed to scanCallback function
//
//  return
//      none
    public void CaysnPos_EnumBleDeviceA(int timeout, IntByReference cancel, on_btdevice_discovered_a_callback scanCallback, Pointer data);

//      Open com port
//
// name 
//      port name
//      for example COM1,COM2,COM3,...COM11...
//
// baudrate 
//      baudrate
//      Normally choose 9600,19200,38400,57600,115200.
//      Need to keep the same as printer baudrate, suggest using high baudrate to get better printing speed.
//
// databits
//      databits, value range is [4,8]
//
// parity 
//      Parity bit, The values are defined as follows:
//      value    define
//      0     no parity
//      1     odd parity
//      2     even parity
//      3     mark parity
//      4     space parity
//
// stopbits 
//      Parity bit, The values are defined as follows:
//      value    define
//      0     1bit stopbits
//      1     1.5bit stopbits
//      2     2bit stopbits
//
// flowcontrol
//      flow control
//
// return 
//      Return handle, If open success, return non-zero value, else return zero.
//
// remarks
//      If serial port was occupied, open serial will fail
//      If baud rate don't match with printer baud rate, it won't print.
    public Pointer CaysnPos_OpenComA(String name, int baudrate, int databits, int parity, int stopbits, int flowcontrol);
    public Pointer CaysnPos_OpenComW(WString name, int baudrate, int databits, int parity, int stopbits, int flowcontrol);

//      Open Tcp
//
// ip 
//      IP Addres or printer name
//      For example: 192.168.1.87
//
// port 
//      Port Number
//      Fixed value: 9100
//
// timeout
//      connect timeout
//
// return 
//      Return handle, If open success, return non-zero value, else return zero.
//
// remarks
//      PC and printer need in the same network segment, so they can connect
    public Pointer CaysnPos_OpenTcpA(String ip, short port, int timeout);
    public Pointer CaysnPos_OpenTcpW(WString ip, short port, int timeout);

//      specify interface Open Tcp
//
// ip 
//      IP Addres or printer name
//      For example: 192.168.1.87
//
// port 
//      Port Number
//      Fixed value: 9100
//
// bind_local_addr 
//      bind to local ip 
//      if there is multiple network cards, you can specify the item 
//      you can also set 0 to auto select
//
// timeout
//      connect timeout
//
// return 
//      Return handle, If open success, return non-zero value, else return zero.
//
// remarks
//      PC and printer need in the same network segment, so they can connect
    public Pointer CaysnPos_OpenTcpBindInterfaceA(String ip, short port, String bind_local_addr, int timeout);
    public Pointer CaysnPos_OpenTcpBindInterfaceW(WString ip, short port, WString bind_local_addr, int timeout);

//      Open Usb
//
// vid 
//      usb vid
//
// pid
//      usb pid
//
// return 
//      Return handle, If open success, return non-zero value, else return zero.
//
// remarks
//      only for android
    public Pointer CaysnPos_OpenUsbVidPid(short vid, short pid);
    public Pointer CaysnPos_OpenUsbVidPidStringA(String name);
    public Pointer CaysnPos_OpenUsbVidPidStringW(WString name);

//      Connect Bluetooth2.0 Printer
//
// address 
//      bluetooth address
//
// return 
//      Return handle, If open success, return non-zero value, else return zero.
//
// remarks
//      only for android
    public Pointer CaysnPos_OpenBT2ByConnectA(String address);
    public Pointer CaysnPos_OpenBT2ByConnectW(WString address);

//      Listen Bluetooth2.0 Printer
//
// timeout
//      connect timeout
//
// address 
//      save connected printer bluetooth address
//
// return 
//      Return handle, If open success, return non-zero value, else return zero.
//
// remarks
//      only for android
    public Pointer CaysnPos_OpenBT2ByListenA(int timeout, byte[] address);

//      Connect Bluetooth4.0 Printer
//
// address 
//      bluetooth address
//
// return 
//      Return handle, If open success, return non-zero value, else return zero.
//
// remarks
//      only for android
    public Pointer CaysnPos_OpenBT4ByConnectA(String address);
    public Pointer CaysnPos_OpenBT4ByConnectW(WString address);

//      Open file
//
// name
//      file name
//
// return 
//      Return handle, If open success, return non-zero value, else return zero.
//
// remarks
//      just can write, but can't read
//      All the query status function are invalid
    public Pointer CaysnPos_OpenFileNewA(String name);
    public Pointer CaysnPos_OpenFileNewW(WString name);

//      Open file, the data will append to the file
//
// name
//      file name
//
// return 
//      Return handle, If open success, return non-zero value, else return zero.
//
// remarks
//      just can write, but can't read
//      All the query status function are invalid
    public Pointer CaysnPos_OpenFileAppendA(String name);
    public Pointer CaysnPos_OpenFileAppendW(WString name);

//      alloc an memory space, the data will write to the memory
//
// nMemorySpaceSize
//      memory space size
//
// return 
//      Return handle, If open success, return non-zero value, else return zero.
//
// remarks
//      just can write, but can't read
//      All the query status function are invalid
//      data accessed by MemoryData MemoryDataLength
//      data clear by ClearMemoryData
    public Pointer CaysnPos_OpenMemory(int nMemorySpaceSize);

//      get memory data
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      memory pointer
//
// remarks
//      none
    public Pointer CaysnPos_MemoryData(Pointer handle);
    public class CaysnPos_MemoryData_Helper {
        public static byte[] CaysnPos_MemoryByteArray(Pointer handle) {
            Pointer pdata = INSTANCE.CaysnPos_MemoryData(handle);
            int data_size = INSTANCE.CaysnPos_MemoryDataLength(handle);
            if (pdata != Pointer.NULL) {
                byte[] buffer = pdata.getByteArray(0, data_size);
                return buffer;
            }
            return null;
        }
    }

//      memory data length
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      memory data length
//
// remarks
//      none
    public int CaysnPos_MemoryDataLength(Pointer handle);

//      clear memory data buffer
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      none
//
// remarks
//      none
    public void CaysnPos_ClearMemoryData(Pointer handle);


    interface on_bytes_writed_callback extends Callback {
        // scanCallback not support byte[]
        void on_bytes_writed(Pointer buffer, int count, Pointer private_data);
    }
    public int CaysnPos_SetWritedEvent(Pointer handle, on_bytes_writed_callback scanCallback, Pointer private_data);


    interface on_bytes_readed_callback extends Callback {
        // scanCallback not support byte[]
        void on_bytes_readed(Pointer buffer, int count, Pointer private_data);
    }
    public int CaysnPos_SetReadedEvent(Pointer handle, on_bytes_readed_callback scanCallback, Pointer private_data);


    interface on_port_closed_callback extends Callback {
        void on_port_closed(Pointer private_data);
    }
    public int CaysnPos_SetClosedEvent(Pointer handle, on_port_closed_callback scanCallback, Pointer private_data);

//      Write data to port
//
// handle 
//      Port handle, returned by OpenXXX
//
// buffer 
//      buffer
//
// count 
//      buffer length
//
// timeout 
//      Timeout ms
//
// return 
//      return bytes writted. or return -1 means failed
    public int CaysnPos_Write(Pointer handle, byte[] buffer, int count, int timeout);

//      Receive data from port
//
// handle 
//      Port handle, returned by OpenXXX
//
// buffer 
//      buffer
//
// count 
//      buffer length
//
// timeout 
//      Timeout ms
//
// return 
//      return bytes readed. or return -1 means failed
    public int CaysnPos_Read(Pointer handle, byte[] buffer, int count, int timeout);

//      Receive data from port
//
// handle 
//      Port handle, returned by OpenXXX
//
// buffer 
//      buffer
//
// count 
//      buffer length
//
// timeout 
//      Timeout ms
//
// breakByte
//      break read byte
//
// return 
//      return bytes readed. or return -1 means failed
    public int CaysnPos_ReadUntilByte(Pointer handle, byte[] buffer, int count, int timeout, byte breakByte);

//      Skip receive buffer
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      none
    public void CaysnPos_SkipAvailable(Pointer handle);

//      flush write buffer, only available for Prn Port
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      none
    public void CaysnPos_FlushBuffer(Pointer handle);

//      Close Port
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      none
    public void CaysnPos_Close(Pointer handle);

//      Query and wait for the printer buffer empty
//
// handle 
//      Port handle, returned by OpenXXX
//
// timeout 
//      timeout ms
//
// return 
//      return whether the buffer is empty. the value defined as follow:
//      value define
//      0     printer buffer is empty
//      -1    the port is closed
//      -2    write failed
//      -3    read failed
//      -4    printer buffer is not empty
    public int CaysnPos_QueryPrinterBufferEmpty(Pointer handle, int timeout);

//      real time query printer status(drawer, paper, error)
//
// handle 
//      Port handle, returned by OpenXXX
//
// timeout 
//      timeout ms
//
// return 
//      return printer status, or -1 if query status failed
//      can access detailed status information via macro definition
    public int CaysnPos_QueryPrinterStatus(Pointer handle, int timeout);

//      Query print result
//
// handle 
//      Port handle, returned by OpenXXX
//
// timeout 
//      timeout ms
//
// return 
//      return value indicate the print result.
//      the value defined as follow:
//      value define
//      0     print success
//      -1    the port is closed
//      -2    write failed
//      -3    read failed
//      -4    printer no response
//      -102    printer is offline
//      -103    printer is nopaper
//      -101    other error
    public int CaysnPos_QueryPrintResult(Pointer handle, int timeout);

//      Turn on cashbox
//
// handle 
//      Port handle, returned by OpenXXX
//
// nDrawerIndex 
//      Cashbox no, value are defined as follow:
//      value      define
//        0      Cashbox pin 2
//        1      Cashbox pin 5
//
// nHighLevelTime 
//      Cashbox pulse high potential ms time
//
// nLowLevelTime 
//      Cashbox pulse low potential ms time
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_KickOutDrawer(Pointer handle, int nDrawerIndex, int nHighLevelTime, int nLowLevelTime);

//      Buzzer call
//
// handle 
//      Port handle, returned by OpenXXX
//
// nBeepCount
//      Calling times
//
// nBeepMs
//      Calling time ms, value range is [100,900], flour to 100 milliseconds.
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_Beep(Pointer handle, int nBeepCount, int nBeepMs);

//      feed to cutter position and half cut paper
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_FeedAndHalfCutPaper(Pointer handle);

//      full cut paper
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_FullCutPaper(Pointer handle);

//      half cut paper
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_HalfCutPaper(Pointer handle);

//      reset printer, clear settings
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_ResetPrinter(Pointer handle);

//      set printer
//
// handle 
//      Port handle, returned by OpenXXX
//
// setType
//      set type
//
// buffer 
//      buffer
//
// count 
//      buffer length
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetPrinter(Pointer handle, int setType, byte[] buffer, int count);

//      set print speed (some printer suppert)
//
// handle 
//      Port handle, returned by OpenXXX
//
// nSpeed
//      print speed in mm/s
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetPrintSpeed(Pointer handle, int nSpeed);

//      set print density (some printer suppert)
//
// handle 
//      Port handle, returned by OpenXXX
//
// nDensity
//      the print density, the value defined as follow:
//      value define
//      0     light
//      1     normal
//      2     dark
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetPrintDensity(Pointer handle, int nDensity);

//      set print heat para (some printer suppert)
//
// handle 
//      Port handle, returned by OpenXXX
//
// nMaxHeatDots
//      max heat dots
//
// nHeatOnTime
//      heat on time(us)
//
// nHeatOffTime
//      heat off time(us)
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetPrintHeatPara(Pointer handle, int nMaxHeatDots, int nHeatOnTime, int nHeatOffTime);

//      printer print self test page
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintSelfTestPage(Pointer handle);

//      set print movement unit
//
// handle 
//      Port handle, returned by OpenXXX
//
// nHorizontalMovementUnit
//      horizontal movement unit
//
// nVerticalMovementUnit
//      vertical movement unit
//
// return 
//      If command is written successfully, it returns true else it returns false.
//
// remarks
//      if set movement unit to 200, 1mm means 8point.
    public int CaysnPos_SetMovementUnit(Pointer handle, int nHorizontalMovementUnit, int nVerticalMovementUnit);

//      set print area left margin
//
// handle 
//      Port handle, returned by OpenXXX
//
// nLeftMargin
//      print area left margin
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetPrintAreaLeftMargin(Pointer handle, int nLeftMargin);

//      set print area width
//
// handle 
//      Port handle, returned by OpenXXX
//
// nWidth
//      print area width
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetPrintAreaWidth(Pointer handle, int nWidth);

//      set horizontal absolute print position
//
// handle 
//      Port handle, returned by OpenXXX
//
// nPosition
//      print position
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetHorizontalAbsolutePrintPosition(Pointer handle, int nPosition);

//      set horizontal relative print position
//
// handle 
//      Port handle, returned by OpenXXX
//
// nPosition
//      print position
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetHorizontalRelativePrintPosition(Pointer handle, int nPosition);

//      set print alignment
//
// handle 
//      Port handle, returned by OpenXXX
//
// nAlignment
//      print alignment, value are defined as follow:
//      value define
//      0     align left
//      1     align center
//      2     align right
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetAlignment(Pointer handle, int nAlignment);

//      printer feed numLines
//
// handle 
//      Port handle, returned by OpenXXX
//
// numLines
//      number of lines to feed
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_FeedLine(Pointer handle, int numLines);

//      printer feed numDots
//
// handle 
//      Port handle, returned by OpenXXX
//
// numDots
//      number of dots to feed
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_FeedDot(Pointer handle, int numDots);

//       print text
//
// handle 
//      Port handle, returned by OpenXXX
//
// str 
//      the string to print
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintTextA(Pointer handle, String str);

//       print text
//
// handle 
//      Port handle, returned by OpenXXX
//
// str 
//      the string to print
//
// return 
//      If command is written successfully, it returns true else it returns false.
// 
// remarks
//      The function converts the data to UTF8 encoding.
    public int CaysnPos_PrintTextInUTF8W(Pointer handle, WString str);

//       print text
//
// handle 
//      Port handle, returned by OpenXXX
//
// str 
//      the string to print
//
// return 
//      If command is written successfully, it returns true else it returns false.
// 
// remarks
//      The function converts the data to GBK encoding.
    public int CaysnPos_PrintTextInGBKW(Pointer handle, WString str);

//       print text
//
// handle 
//      Port handle, returned by OpenXXX
//
// str 
//      the string to print
//
// return 
//      If command is written successfully, it returns true else it returns false.
// 
// remarks
//      The function converts the data to BIG5 encoding.
    public int CaysnPos_PrintTextInBIG5W(Pointer handle, WString str);

//       print text
//
// handle 
//      Port handle, returned by OpenXXX
//
// str 
//      the string to print
//
// return 
//      If command is written successfully, it returns true else it returns false.
// 
// remarks
//      The function converts the data to ShiftJIS encoding.
    public int CaysnPos_PrintTextInShiftJISW(Pointer handle, WString str);

//       print text
//
// handle 
//      Port handle, returned by OpenXXX
//
// str 
//      the string to print
//
// return 
//      If command is written successfully, it returns true else it returns false.
// 
// remarks
//      The function converts the data to EUCKR encoding.
    public int CaysnPos_PrintTextInEUCKRW(Pointer handle, WString str);

//      set text scale
//
// handle 
//      Port handle, returned by OpenXXX
//
// nWidthScale
//      width scale
//
// nHeightScale
//      height scale
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetTextScale(Pointer handle, int nWidthScale, int nHeightScale);

//      set ascii text font type
//
// handle 
//      Port handle, returned by OpenXXX
//
// nFontType
//      ascii text font type, values defined as follow:
//      value define
//      0     FontA (12x24)
//      1     FontB (9x17)
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetAsciiTextFontType(Pointer handle, int nFontType);

//      set text bold
//
// handle 
//      Port handle, returned by OpenXXX
//
// nBold
//      text bold , values defined as follow:
//      value define
//      0     don't bold
//      1     bold
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetTextBold(Pointer handle, int nBold);

//      set text underline
//
// handle 
//      Port handle, returned by OpenXXX
//
// nUnderline
//      text underline, values defined as follow:
//      value define
//      0     no underline
//      1     1 point underline
//      2     2 point underline
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetTextUnderline(Pointer handle, int nUnderline);

//      set text upside down
//
// handle 
//      Port handle, returned by OpenXXX
//
// nUpsideDown
//      upside down, values defined as follow:
//      value define
//      0     print text dont't upside down 
//      1     print text upside down
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetTextUpsideDown(Pointer handle, int nUpsideDown);

//      set text black and white reverse
//
// handle 
//      Port handle, returned by OpenXXX
//
// nWhiteOnBlack
//      black and white reverse, values defined as follow: 
//      value define
//      0     print text normal
//      1     print text black and white reverse
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetTextWhiteOnBlack(Pointer handle, int nWhiteOnBlack);

//      set text rotate 90 print
//
// handle 
//      Port handle, returned by OpenXXX
//
// nRotate
//      set text rotate, value defined as follow:
//      value define
//      0     print normal
//      1     text print rotate 90 degree
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetTextRotate(Pointer handle, int nRotate);

//      set line height
//
// handle 
//      Port handle, returned by OpenXXX
//
// nLineHeight
//      line height, value range is [1,255]
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetTextLineHeight(Pointer handle, int nLineHeight);

//      set ascii text char right spacing
//
// handle 
//      Port handle, returned by OpenXXX
//
// nSpacing
//      right spacing, range is [1,255]
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetAsciiTextCharRightSpacing(Pointer handle, int nSpacing);

//      set kanji text char left spacing and right spacing
//
// handle 
//      Port handle, returned by OpenXXX
//
// nLeftSpacing
//      left spacing, range is [1,255]
//
// nRightSpacing
//      right spacing, range is [1,255]
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetKanjiTextCharSpacing(Pointer handle, int nLeftSpacing, int nRightSpacing);

//      set printer to single byte mode
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetSingleByteMode(Pointer handle);

//      set print speed (some printer suppert)
//
// handle 
//      Port handle, returned by OpenXXX
//
// nCharacterSet
//      character set, range is [0, 15]
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetCharacterSet(Pointer handle, int nCharacterSet);

//      set character codepage
//
// handle 
//      Port handle, returned by OpenXXX
//
// nCharacterCodepage
//      character codepage, range is [0,255]
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetCharacterCodepage(Pointer handle, int nCharacterCodepage);

//      set printer to multi byte mode
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetMultiByteMode(Pointer handle);

//      set printer multi byte encoding
//
// handle 
//      Port handle, returned by OpenXXX
//
// nEncoding
//      multi byte encoding, values defined as follow:
//      value define
//      0     GBK
//      1     UTF8
//      3     BIG5
//      4     SHIFT-JIS
//      5     EUC-KR
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetMultiByteEncoding(Pointer handle, int nEncoding);

//      set user character pattern
//
// handle 
//      Port handle, returned by OpenXXX
//
// ch
//      the char to define, value range is [0x20, 0x7E]
//
// pszFile
//      image file path
//
// return 
//      If command is written successfully, it returns true else it returns false.
//
// remarks
//      if image size is not 12x24, will scale to 12x24
    public int CaysnPos_SetUserCharacterPatternFromFileA(Pointer handle, byte ch, String pszFile);
    public int CaysnPos_SetUserCharacterPatternFromFileW(Pointer handle, byte ch, WString pszFile);

//      set user character pattern
//
// handle 
//      Port handle, returned by OpenXXX
//
// ch
//      the char to define, value range is [0x20, 0x7E]
//
// data 
//      image data
//
// data_size 
//      image data size
//
// return 
//      If command is written successfully, it returns true else it returns false.
//
// remarks
//      if image size is not 12x24, will scale to 12x24
    public int CaysnPos_SetUserCharacterPatternFromData(Pointer handle, byte ch, byte[] data, int data_size);
    public class CaysnPos_SetUserCharacterPattern_Helper {
        public static int CaysnPos_SetUserCharacterPatternFromBitmap(Pointer handle, byte ch, Bitmap bitmap) {
            int result = 0;
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            if (bitmap.compress(Bitmap.CompressFormat.PNG, 100, os)) {
                byte[] data = os.toByteArray();
                result = INSTANCE.CaysnPos_SetUserCharacterPatternFromData(handle, ch, data, data.length);
            }
            return result;
        }
    }

//      set user character pattern
//
// handle 
//      Port handle, returned by OpenXXX
//
// ch
//      the char to define, value range is [0x20, 0x7E]
//
// img_data 
//      image pixels data
//
// img_datalen
//      image pixels data length
//
// img_width 
//      image pixel width
//
// img_height 
//      image pixel height
//
// img_stride 
//      image horizontal stirde. means bytes per line.
//
// img_format
//      image pixel data format, values are defined as follow
//      value define
//      1     mono 
//      2     monolsb 
//      3     gray
//      4     r.g.b in byte-ordered
//      5     b.g.r in byte-ordered
//      6     a.r.g.b in byte-ordered
//      7     r.g.b.a in byte-ordered
//      8     a.b.g.r in byte-ordered
//      9     b.g.r.a in byte-ordered
//
// return 
//      If command is written successfully, it returns true else it returns false.
// 
// remarks
//      if image size is not 12x24, will scale to 12x24
    public int CaysnPos_SetUserCharacterPatternFromPixels(Pointer handle, byte ch, byte[] img_data, int img_datalen, int img_width, int img_height, int img_stride, int img_format);

//      clear user character pattern
//
// handle 
//      Port handle, returned by OpenXXX
//
// ch
//      the char to clear user pattern, value range is [0x20, 0x7E]
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_ClearUserCharacterPattern(Pointer handle, byte ch);

//      set if use user character
//
// handle 
//      Port handle, returned by OpenXXX
//
// enable
//      use or not
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetUserCharacterEnable(Pointer handle, int enable);

//      set user kanji pattern
//
// handle 
//      Port handle, returned by OpenXXX
//
// c1
//      user kanji code byte 1
//
// c2
//      user kanji code byte 2
//
// pszFile
//      image file path
//
// return 
//      If command is written successfully, it returns true else it returns false.
//
// remarks
//      if image size is not 24x24, will scale to 24x24
    public int CaysnPos_SetUserKanjiPatternFromFileA(Pointer handle, byte c1, byte c2, String pszFile);
    public int CaysnPos_SetUserKanjiPatternFromFileW(Pointer handle, byte c1, byte c2, WString pszFile);

//      set user kanji pattern
//
// handle 
//      Port handle, returned by OpenXXX
//
// c1
//      user kanji code byte 1
//
// c2
//      user kanji code byte 2
//
// data 
//      image data
//
// data_size 
//      image data size
//
// return 
//      If command is written successfully, it returns true else it returns false.
//
// remarks
//      if image size is not 24x24, will scale to 24x24
    public int CaysnPos_SetUserKanjiPatternFromData(Pointer handle, byte c1, byte c2, byte[] data, int data_size);
    public class CaysnPos_SetUserKanjiPattern_Helper {
        public static int CaysnPos_SetUserKanjiPatternFromBitmap(Pointer handle, byte c1, byte c2, Bitmap bitmap) {
            int result = 0;
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            if (bitmap.compress(Bitmap.CompressFormat.PNG, 100, os)) {
                byte[] data = os.toByteArray();
                result = INSTANCE.CaysnPos_SetUserKanjiPatternFromData(handle, c1, c2, data, data.length);
            }
            return result;
        }
    }

//      set user kanji pattern
//
// handle 
//      Port handle, returned by OpenXXX
//
// c1
//      user kanji code byte 1
//
// c2
//      user kanji code byte 2
//
// img_data 
//      image pixels data
//
// img_datalen
//      image pixels data length
//
// img_width 
//      image pixel width
//
// img_height 
//      image pixel height
//
// img_stride 
//      image horizontal stirde. means bytes per line.
//
// img_format
//      image pixel data format, values are defined as follow
//      value define
//      1     mono 
//      2     monolsb 
//      3     gray
//      4     r.g.b in byte-ordered
//      5     b.g.r in byte-ordered
//      6     a.r.g.b in byte-ordered
//      7     r.g.b.a in byte-ordered
//      8     a.b.g.r in byte-ordered
//      9     b.g.r.a in byte-ordered
//
// return 
//      If command is written successfully, it returns true else it returns false.
// 
// remarks
//      if image size is not 24x24, will scale to 24x24
    public int CaysnPos_SetUserKanjiPatternFromPixels(Pointer handle, byte c1, byte c2, byte[] img_data, int img_datalen, int img_width, int img_height, int img_stride, int img_format);

//      print 1D barcode
//
// handle 
//      Port handle, returned by OpenXXX
//
// nBarcodeType 
//      barcode type
//      values are defined as follow:
//      value    type
//      0x41     UPC-A
//      0x42     UPC-E
//      0x43     EAN13
//      0x44     EAN8
//      0x45     CODE39
//      0x46     ITF
//      0x47     CODABAR
//      0x48     CODE93
//      0x49     CODE128
//
// str 
//      the barcode data to print
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintBarcodeA(Pointer handle, int nBarcodeType, String str);
    public int CaysnPos_PrintBarcodeW(Pointer handle, int nBarcodeType, WString str);

//      set barcode and qrcode unit width
//
// handle 
//      Port handle, returned by OpenXXX
//
// nBarcodeUnitWidth
//      It assigns the code basic element width. range is [2,6]
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetBarcodeUnitWidth(Pointer handle, int nBarcodeUnitWidth);

//      set barcode height
//
// handle 
//      Port handle, returned by OpenXXX
//
// nBarcodeHeight 
//      Barcode height, range is [1,255]
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetBarcodeHeight(Pointer handle, int nBarcodeHeight);

//      set barcode readable text font type
//
// handle 
//      Port handle, returned by OpenXXX
//
// nFontType
//      It assigns HRI(Human Readable Interpretation) character font types.
//      value type
//      0     standard ASCII
//      1     small ASCII
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetBarcodeReadableTextFontType(Pointer handle, int nFontType);

//      set barcode readable text print position
//
// handle 
//      Port handle, returned by OpenXXX
//
// nTextPosition
//      barcode readable text position, value range is [0, 3].
//      value defined as follow:
//      value define
//      0     don't show readable text
//      1     show readable text below barcode
//      2     show readable text above barcode
//      3     show readable text above and below barcode
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetBarcodeReadableTextPosition(Pointer handle, int nTextPosition);

//      print qrcode
//
// handle 
//      Port handle, returned by OpenXXX
//
// nVersion 
//      Assign charater version. The value range is:[0,16]
//      When version is 0, printer caculates version number according to character set automatically.
//
// nECCLevel 
//      Assign error correction level.
//      The value range is: [1, 4].
//      Definitios are as below:
//      ECC error correction level
//      1   L:7%, low error correction, much data.
//      2   M:15%, medium error correction
//      3   Q:optimize error correction
//      4   H:30%, the highest error correction, less data.
//
// str 
//      the qrcode data to print
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintQRCodeA(Pointer handle, int nVersion, int nECCLevel, String str);
    public int CaysnPos_PrintQRCodeW(Pointer handle, int nVersion, int nECCLevel, WString str);

//      print qrcode
//
// handle 
//      Port handle, returned by OpenXXX
//
// nQRCodeUnitWidth 
//     QRCode code block width, the value range is [1, 16]
//
// nECCLevel 
//      Assign error correction level.
//      The value range is: [1, 4].
//      Definitios are as below:
//      ECC error correction level
//      1   L:7%, low error correction, much data.
//      2   M:15%, medium error correction
//      3   Q:optimize error correction
//      4   H:30%, the highest error correction, less data.
//
// str 
//      the qrcode data to print
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintQRCodeUseEpsonCmdA(Pointer handle, int nQRCodeUnitWidth, int nECCLevel, String str);
    public int CaysnPos_PrintQRCodeUseEpsonCmdW(Pointer handle, int nQRCodeUnitWidth, int nECCLevel, WString str);

//      print 2 qrcode
//
// handle 
//      Port handle, returned by OpenXXX
//
// nQRCodeUnitWidth 
//     QRCode code block width, the value range is [1, 8]
//
// nQR1Position
// nQR2Position
//      QRCode position
//
// nQR1Version 
// nQR2Version 
//      Assign charater version. The value range is:[0,16]
//      When version is 0, printer caculates version number according to character set automatically.
//
// nQR1ECCLevel 
// nQR2ECCLevel 
//      Assign error correction level.
//      The value range is: [1, 4].
//      Definitios are as below:
//      ECC error correction level
//      1   L:7%, low error correction, much data.
//      2   M:15%, medium error correction
//      3   Q:optimize error correction
//      4   H:30%, the highest error correction, less data.
//
// strQR1 
// strQR2
//      the qrcode data to print
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintDoubleQRCodeA(Pointer handle, int nQRCodeUnitWidth, int nQR1Position, int nQR1Version, int nQR1ECCLevel, String strQR1, int nQR2Position, int nQR2Version, int nQR2ECCLevel, String strQR2);
    public int CaysnPos_PrintDoubleQRCodeW(Pointer handle, int nQRCodeUnitWidth, int nQR1Position, int nQR1Version, int nQR1ECCLevel, WString strQR1, int nQR2Position, int nQR2Version, int nQR2ECCLevel, WString strQR2);

//      print pdf417 barcode
//
// handle 
//      Port handle, returned by OpenXXX
//
// columnCount
//      column count, range is [0,30]
//
// rowCount
//      row count, range is 0,[3,90]
//
// unitWidth
//      module unit width, range is [2,8]
//
// rowHeight 
//      row height, range is [2,8]
//
// nECCLevel 
//      ecc level, range is [0,8]
//
// dataProcessingMode
//      data processing mode, 0 select standard PDF417, 1 select cutoff PDF417
//
// str 
//      the pdf417 data to print
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintPDF417BarcodeUseEpsonCmdA(Pointer handle, int columnCount, int rowCount, int unitWidth, int rowHeight, int nECCLevel, int dataProcessingMode, String str);
    public int CaysnPos_PrintPDF417BarcodeUseEpsonCmdW(Pointer handle, int columnCount, int rowCount, int unitWidth, int rowHeight, int nECCLevel, int dataProcessingMode, WString str);

//      get image width and height
//
// pszFile 
//      image file path
//
// depth
//      image depth
//
// width 
//      image width
//
// height 
//      image height
//
// return 
//      The return value indicates whether a successful. return of true indicates success, or false indicates failure
    public int CaysnPos_GetImageSizeFromFileA(String pszFile, IntByReference depth, IntByReference width, IntByReference height);
    public int CaysnPos_GetImageSizeFromFileW(WString pszFile, IntByReference depth, IntByReference width, IntByReference height);

//      Get the image width and height from the image data
//
// data 
//      image data
//
// data_size 
//      image data size
//
// depth
//      image depth
//
// width 
//      image width
//
// height 
//      image height
//
// return 
//      The return value indicates whether a successful. return of true indicates success, or false indicates failure
// 
// remarks
//      Supports access to mainstream image format information, including but not limited to BMP,JPG,PNG, etc.
    public int CaysnPos_GetImageSizeFromData(byte[] data, int data_size, IntByReference depth, IntByReference width, IntByReference height);

//      print image
//
// handle 
//      Port handle, returned by OpenXXX
//
// dstw 
//      the width to print
//
// dsth 
//      the height to print
//
// pszFile 
//      image file path
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintRasterImageFromFileA(Pointer handle, int dstw, int dsth, String pszFile, int binaryzation_method);
    public int CaysnPos_PrintRasterImageFromFileW(Pointer handle, int dstw, int dsth, WString pszFile, int binaryzation_method);

//      print image (data can be readed from file)
//
// handle 
//      Port handle, returned by OpenXXX
//
// dstw 
//      the width to print
//
// dsth 
//      the height to print
//
// data 
//      image data
//
// data_size 
//      image data size
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintRasterImageFromData(Pointer handle, int dstw, int dsth, byte[] data, int data_size, int binaryzation_method);
    public class CaysnPos_PrintRasterImage_Helper {
        public static int CaysnPos_PrintRasterImageFromBitmap(Pointer handle, int dstw, int dsth, Bitmap bitmap, int binaryzation_method) {
            int result = 0;
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            if (bitmap.compress(Bitmap.CompressFormat.PNG, 100, os)) {
                byte[] data = os.toByteArray();
                result = INSTANCE.CaysnPos_PrintRasterImageFromData(handle, dstw, dsth, data, data.length, binaryzation_method);
            }
            return result;
        }
    }

//      print image pixels
//
// handle 
//      Port handle, returned by OpenXXX
//
// img_data 
//      image pixels data
//
// img_datalen
//      image pixels data length
//
// img_width 
//      image pixel width
//
// img_height 
//      image pixel height
//
// img_stride 
//      image horizontal stirde. means bytes per line.
//
// img_format
//      image pixel data format, values are defined as follow
//      value define
//      1     mono 
//      2     monolsb 
//      3     gray
//      4     r.g.b in byte-ordered
//      5     b.g.r in byte-ordered
//      6     a.r.g.b in byte-ordered
//      7     r.g.b.a in byte-ordered
//      8     a.b.g.r in byte-ordered
//      9     b.g.r.a in byte-ordered
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintRasterImageFromPixels(Pointer handle, byte[] img_data, int img_datalen, int img_width, int img_height, int img_stride, int img_format, int binaryzation_method);

//      print image
//
// handle 
//      Port handle, returned by OpenXXX
//
// dstw 
//      the width to print
//
// dsth 
//      the height to print
//
// pszFile 
//      image file path
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// compress_method
//      print data compress method, values are defined as follow
//      value define
//      0     no compress
//      1     compress level 1
//      2     compress level 2
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintRasterImageWithCompressFromFileA(Pointer handle, int dstw, int dsth, String pszFile, int binaryzation_method, int compress_method);
    public int CaysnPos_PrintRasterImageWithCompressFromFileW(Pointer handle, int dstw, int dsth, WString pszFile, int binaryzation_method, int compress_method);

//      print image (data can be readed from file)
//
// handle 
//      Port handle, returned by OpenXXX
//
// dstw 
//      the width to print
//
// dsth 
//      the height to print
//
// data 
//      image data
//
// data_size 
//      image data size
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// compress_method
//      print data compress method, values are defined as follow
//      value define
//      0     no compress
//      1     compress level 1
//      2     compress level 2
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintRasterImageWithCompressFromData(Pointer handle, int dstw, int dsth, byte[] data, int data_size, int binaryzation_method, int compress_method);
    public class CaysnPos_PrintRasterImageWithCompress_Helper {
        public static int CaysnPos_PrintRasterImageWithCompressFromBitmap(Pointer handle, int dstw, int dsth, Bitmap bitmap, int binaryzation_method, int compress_method) {
            int result = 0;
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            if (bitmap.compress(Bitmap.CompressFormat.PNG, 100, os)) {
                byte[] data = os.toByteArray();
                result = INSTANCE.CaysnPos_PrintRasterImageWithCompressFromData(handle, dstw, dsth, data, data.length, binaryzation_method, compress_method);
            }
            return result;
        }
    }

//      print image pixels
//
// handle 
//      Port handle, returned by OpenXXX
//
// img_data 
//      image pixels data
//
// img_datalen
//      image pixels data length
//
// img_width 
//      image pixel width
//
// img_height 
//      image pixel height
//
// img_stride 
//      image horizontal stirde. means bytes per line.
//
// img_format
//      image pixel data format, values are defined as follow
//      value define
//      1     mono 
//      2     monolsb 
//      3     gray
//      4     r.g.b in byte-ordered
//      5     b.g.r in byte-ordered
//      6     a.r.g.b in byte-ordered
//      7     r.g.b.a in byte-ordered
//      8     a.b.g.r in byte-ordered
//      9     b.g.r.a in byte-ordered
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// compress_method
//      print data compress method, values are defined as follow
//      value define
//      0     no compress
//      1     compress level 1
//      2     compress level 2
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintRasterImageWithCompressFromPixels(Pointer handle, byte[] img_data, int img_datalen, int img_width, int img_height, int img_stride, int img_format, int binaryzation_method, int compress_method);

//      fill image to current line
//
// handle 
//      Port handle, returned by OpenXXX
//
// pszFile 
//      image file path
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// return 
//      If command is written successfully, it returns true else it returns false.
//
// remarks
//      if image is higher than 24, will scale to 24 pixel print.
//      if image is no more than 24, will padding to 24 pixel print.
    public int CaysnPos_FillDotImageToCurrentLineFromFileA(Pointer handle, String pszFile, int binaryzation_method);
    public int CaysnPos_FillDotImageToCurrentLineFromFileW(Pointer handle, WString pszFile, int binaryzation_method);

//      fill image to current line
//
// handle 
//      Port handle, returned by OpenXXX
//
// data 
//      image data
//
// data_size 
//      image data size
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// return 
//      If command is written successfully, it returns true else it returns false.
//
// remarks
//      if image is higher than 24, will scale to 24 pixel print.
//      if image is no more than 24, will padding to 24 pixel print.
    public int CaysnPos_FillDotImageToCurrentLineFromData(Pointer handle, byte[] data, int data_size, int binaryzation_method);
    public class CaysnPos_FillDotImageToCurrentLine_Helper {
        public static int CaysnPos_FillDotImageToCurrentLineFromBitmap(Pointer handle, Bitmap bitmap, int binaryzation_method) {
            int result = 0;
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            if (bitmap.compress(Bitmap.CompressFormat.PNG, 100, os)) {
                byte[] data = os.toByteArray();
                result = INSTANCE.CaysnPos_FillDotImageToCurrentLineFromData(handle, data, data.length, binaryzation_method);
            }
            return result;
        }
    }

//      fill image to current line
//
// handle 
//      Port handle, returned by OpenXXX
//
// img_data 
//      image pixels data
//
// img_datalen
//      image pixels data length
//
// img_width 
//      image pixel width
//
// img_height 
//      image pixel height
//
// img_stride 
//      image horizontal stirde. means bytes per line.
//
// img_format
//      image pixel data format, values are defined as follow
//      value define
//      1     mono 
//      2     monolsb 
//      3     gray
//      4     r.g.b in byte-ordered
//      5     b.g.r in byte-ordered
//      6     a.r.g.b in byte-ordered
//      7     r.g.b.a in byte-ordered
//      8     a.b.g.r in byte-ordered
//      9     b.g.r.a in byte-ordered
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// return 
//      If command is written successfully, it returns true else it returns false.
//
// remarks
//      if image is higher than 24, will scale to 24 pixel print.
//      if image is no more than 24, will padding to 24 pixel print.
    public int CaysnPos_FillDotImageToCurrentLineFromPixels(Pointer handle, byte[] img_data, int img_datalen, int img_width, int img_height, int img_stride, int img_format, int binaryzation_method);

//      print image
//
// handle 
//      Port handle, returned by OpenXXX
//
// nPosition
//      print position
//
// dstw 
//      the width to print
//
// dsth 
//      the height to print
//
// pszFile 
//      image file path
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// return 
//      If command is written successfully, it returns true else it returns false.
//
// remarks
//      if image height is not a multiple of 24, will padding height to a multiple of 24 pixel print.
    public int CaysnPos_PrintDotImageSpecifyHorizontalPositionFromFileA(Pointer handle, int nPosition, int dstw, int dsth, String pszFile, int binaryzation_method);
    public int CaysnPos_PrintDotImageSpecifyHorizontalPositionFromFileW(Pointer handle, int nPosition, int dstw, int dsth, WString pszFile, int binaryzation_method);

//      print image
//
// handle 
//      Port handle, returned by OpenXXX
//
// nPosition
//      print position
//
// dstw 
//      the width to print
//
// dsth 
//      the height to print
//
// data 
//      image data
//
// data_size 
//      image data size
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// return 
//      If command is written successfully, it returns true else it returns false.
//
// remarks
//      if image height is not a multiple of 24, will padding height to a multiple of 24 pixel print.
    public int CaysnPos_PrintDotImageSpecifyHorizontalPositionFromData(Pointer handle, int nPosition, int dstw, int dsth, byte[] data, int data_size, int binaryzation_method);
    public class CaysnPos_PrintDotImageSpecifyHorizontalPosition_Helper {
        public static int CaysnPos_PrintDotImageSpecifyHorizontalPositionFromBitmap(Pointer handle, int nPosition, int dstw, int dsth, Bitmap bitmap, int binaryzation_method) {
            int result = 0;
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            if (bitmap.compress(Bitmap.CompressFormat.PNG, 100, os)) {
                byte[] data = os.toByteArray();
                result = INSTANCE.CaysnPos_PrintDotImageSpecifyHorizontalPositionFromData(handle, nPosition, dstw, dsth, data, data.length, binaryzation_method);
            }
            return result;
        }
    }

//      print image
//
// handle 
//      Port handle, returned by OpenXXX
//
// nPosition
//      print position
//
// img_data 
//      image pixels data
//
// img_datalen
//      image pixels data length
//
// img_width 
//      image pixel width
//
// img_height 
//      image pixel height
//
// img_stride 
//      image horizontal stirde. means bytes per line.
//
// img_format
//      image pixel data format, values are defined as follow
//      value define
//      1     mono 
//      2     monolsb 
//      3     gray
//      4     r.g.b in byte-ordered
//      5     b.g.r in byte-ordered
//      6     a.r.g.b in byte-ordered
//      7     r.g.b.a in byte-ordered
//      8     a.b.g.r in byte-ordered
//      9     b.g.r.a in byte-ordered
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// return 
//      If command is written successfully, it returns true else it returns false.
//
// remarks
//      if image height is not a multiple of 24, will padding height to a multiple of 24 pixel print.
    public int CaysnPos_PrintDotImageSpecifyHorizontalPositionFromPixels(Pointer handle, int nPosition, byte[] img_data, int img_datalen, int img_width, int img_height, int img_stride, int img_format, int binaryzation_method);

//      define the nv image
//
// handle 
//      Port handle, returned by OpenXXX
//
// count 
//      number of image file
//
// pszFiles 
//      image file path
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetNVImageFromFilesA(Pointer handle, int count, String[] pszFiles);
    public int CaysnPos_SetNVImageFromFilesW(Pointer handle, int count, WString[] pszFiles);

//      define the nv image
//
// handle 
//      Port handle, returned by OpenXXX
//
// count 
//      number of image data
//
// pdata 
//      image data
//
// pdata_size 
//      image data size
//
// return 
//      If command is written successfully, it returns true else it returns false.
    //current not support pass byte[][]
    //public int CaysnPos_SetNVImageFromDatas(Pointer handle, int count, byte[][] pdata, int[] pdata_size);

//      print nv image
//
// handle 
//      Port handle, returned by OpenXXX
//
// no 
//      nv image no. first image no is 1, second image no is 2...
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintNVImage(Pointer handle, int no);

//      clear nv image
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_ClearNVImage(Pointer handle);

//      define the ram image
//
// handle 
//      Port handle, returned by OpenXXX
//
// pszFile
//      image file path
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetRAMImageFromFileA(Pointer handle, int dstw, int dsth, String pszFile, int binaryzation_method);
    public int CaysnPos_SetRAMImageFromFileW(Pointer handle, int dstw, int dsth, WString pszFile, int binaryzation_method);

//      define the ram image
//
// handle 
//      Port handle, returned by OpenXXX
//
// data 
//      image data
//
// data_size 
//      image data size
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetRAMImageFromData(Pointer handle, int dstw, int dsth, byte[] data, int data_size, int binaryzation_method);
    public class CaysnPos_SetRAMImage_Helper {
        public static int CaysnPos_SetRAMImageFromBitmap(Pointer handle, int dstw, int dsth, Bitmap bitmap, int binaryzation_method) {
            int result = 0;
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            if (bitmap.compress(Bitmap.CompressFormat.PNG, 100, os)) {
                byte[] data = os.toByteArray();
                result = INSTANCE.CaysnPos_SetRAMImageFromData(handle, dstw, dsth, data, data.length, binaryzation_method);
            }
            return result;
        }
    }

//      define the ram image
//
// handle 
//      Port handle, returned by OpenXXX
//
// img_data 
//      image pixels data
//
// img_datalen
//      image pixels data length
//
// img_width 
//      image pixel width
//
// img_height 
//      image pixel height
//
// img_stride 
//      image horizontal stirde. means bytes per line.
//
// img_format
//      image pixel data format, values are defined as follow
//      value define
//      1     mono 
//      2     monolsb 
//      3     gray
//      4     r.g.b in byte-ordered
//      5     b.g.r in byte-ordered
//      6     a.r.g.b in byte-ordered
//      7     r.g.b.a in byte-ordered
//      8     a.b.g.r in byte-ordered
//      9     b.g.r.a in byte-ordered
//
// binaryzation_method
//      image binaryzation method. 0 means use dithering, 1 means use thresholding.
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetRAMImageFromPixels(Pointer handle, byte[] img_data, int img_datalen, int img_width, int img_height, int img_stride, int img_format, int binaryzation_method);

//      print RAM image
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintRAMImage(Pointer handle);

//      print one horizontal line
//
// handle 
//      Port handle, returned by OpenXXX
//
// nLineStartPosition
//      line start position
//
// nLineEndPosition
//      line end position
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintHorizontalLine(Pointer handle, int nLineStartPosition, int nLineEndPosition);

//      print one horizontal line
//
// handle 
//      Port handle, returned by OpenXXX
//
// nLineStartPosition
//      line start position
//
// nLineEndPosition
//      line end position
//
// nLineThickness
//      line thickness
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintHorizontalLineSpecifyThickness(Pointer handle, int nLineStartPosition, int nLineEndPosition, int nLineThickness);

//      print multiple horizontal lines at one row, multi call can print curve
//
// handle 
//      Port handle, returned by OpenXXX
//
// nLineCount
//      Line count
//
// pLineStartPosition
//      Line start position
//
// pLineEndPosition
//      Line end position
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_PrintMultipleHorizontalLinesAtOneRow(Pointer handle, int nLineCount, int[] pLineStartPosition, int[] pLineEndPosition);

//      enable black mark mode
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_EnableBlackMarkMode(Pointer handle);

//      disable black mark mode
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_DisableBlackMarkMode(Pointer handle);

//      set black mark max search length(reboot will also valid)
//
// handle 
//      Port handle, returned by OpenXXX
//
// maxFindLength
//      max find length (maxFindLength x 0.125 mm)
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetBlackMarkMaxFindLength(Pointer handle, int maxFindLength);

//      find next black mark
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_FindBlackMark(Pointer handle);

//      in black mode, set start print position
//
// handle 
//      Port handle, returned by OpenXXX
//
// position
//      position > 0 means feed, position < 0 means feedback. distance is position x 0.125 mm.
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetBlackMarkPaperPrintPosition(Pointer handle, int position);

//      in black mark mode, set cut position
//
// handle 
//      Port handle, returned by OpenXXX
//
// position
//      position > 0 means feed, position < 0 means feedback. distance is position x 0.125 mm.
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_SetBlackMarkPaperCutPosition(Pointer handle, int position);

//      full cut paper
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_FullCutBlackMarkPaper(Pointer handle);

//      half cut paper
//
// handle 
//      Port handle, returned by OpenXXX
//
// return 
//      If command is written successfully, it returns true else it returns false.
    public int CaysnPos_HalfCutBlackMarkPaper(Pointer handle);


}

